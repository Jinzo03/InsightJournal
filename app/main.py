from fastapi import FastAPI, Depends
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi import HTTPException
from pydantic import BaseModel
from typing import Optional
from sqlalchemy.orm import Session

from textblob import TextBlob
import csv
import io
from fastapi.responses import StreamingResponse


# IMPORT YOUR NEW FILES 
from app import models, database

#1. CREATE THE DATABASE TABLES (The migration)
# This line runs once. It says : "Engine, go check 'models.Base' and create any listing tables."
models.Base.metadata.create_all(bind=database.engine)

class JournalEntry(BaseModel):
    content: str
    mood: int

class JournalEntryUpdate(BaseModel):
    content: Optional[str] = None
    mood: Optional[int] = None

app=FastAPI()


# Dependency to get DB session
def get_db():
    db = database.SessionLocal()
    try:
        yield db
    finally:
        db.close() # <-- This ensures we never leave a connection hanging

# Serve Static Files        
app.mount("/static", StaticFiles(directory="static"), name="static")

# The Health Check Route 
@app.get("/api/health")
async def health_check():
    return {
        "status": "Online",
        "message": "System is operational"
    }   

# The Index Route
@app.get("/")
async def read_index():
    return FileResponse('static/index.html')

# The Create Entry Route
@app.post("/api/create_entry")
async def create_entry(entry: JournalEntry, db: Session = Depends(get_db)):
    # AI ANALYSIS (Mood Calculation)
    # 0. Print exactly what Python sees (Debugging)
    print(f"--- DEBUG: Content received: '{entry.content}' ---")
    # 1. Feed the text into the machine
    analysis=TextBlob(entry.content)

    #2. Get the "Polarity" (-1 is Angry/Sad, +1 is Happy, 0 is Neutral)
    sentiment_score = analysis.sentiment.polarity

    print(f"AI ANALYSIS : Polarity is {sentiment_score}")
    #-----------------------------------------------------------
    #1. Convert Pydantic (Validation) to SQLAlchemy (Database)
    # We take the data from the user ('entry" and put it into the Database Row ('db_entry')
    db_entry = models.Entry(content=entry.content, mood=entry.mood,sentiment=sentiment_score)

    #2. Add to the 'Staging Area'
    db.add(db_entry)

    #3. Commit (Save to Hard Drive)
    db.commit()

    #4. Refresh (Get the new ID generated by the Database)
    db.refresh(db_entry)
    print(f"SAVED TO DB: ID {db_entry.id} | Content {db_entry.content} | Mood {db_entry.mood}")

    return {"message": "Saved to Database!", "id": db_entry.id, "ai_score": sentiment_score}

# -------------------------------------------
# Get all entries Route
# -------------------------------------------

@app.get("/api/entries")
async def get_entries(db: Session = Depends(get_db)):
    #1. Query The Database
    # This translates to SQL : "SELECT * From entries"
    entries=db.query(models.Entry).all()

    #2. Return the list
    return entries # http://127.0.0.1:8000/api/entries

@app.get("/api/export")
def export_entries(db: Session = Depends(get_db)):
    # 1. Get all data
    entries = db.query(models.Entry).all()

    # 2. Create an "in-memory" file (like a virtual text file)
    output = io.StringIO()
    writer = csv.writer(output)

    # 3. Write the Header Row
    writer.writerow(["ID", "Date", "Mood", "AI_Sentiment", "Content"])
    
    # 4. Write in Data Rows
    for entry in entries:
        writer.writerow([
            entry.id,
            entry.created_at,
            entry.mood,
            entry.sentiment,
            entry.content
        ])

    # 5 . Reset the "cursor" to the start of the file
    output.seek(0)

    #6. Send it to the browser as a download
    return StreamingResponse(
        iter([output.getvalue()]),
        media_type="text/csv",
        headers={"Content-Disposition": "attachement; filename=my_journal.csv"}
    ) 
# The AI Therapist Logic

@app.get("/api/analyze_week")
async def analyze_week(db: Session = Depends(get_db)):
    # 1. Fetch the last 7 entries using SQLAlchemy
    entries = db.query(models.Entry).order_by(models.Entry.created_at.desc()).limit(7).all()

    # SAFETY CHECK: If the user is new, stop here.
    if not entries:
        return {"advice": "I need more data! Write at least one entry so I can help."}
    
    # 2. Extract just the mood numbers into a list
    moods = [int(e.mood) for e in entries]

    # Calcute Average Mood
    avg_mood = float(sum(moods) / len (moods))

    # Calculate Trend
    recent_moods = moods[:3] # The first 3 items (newest)
    older_moods = moods[3:] # The rest (older)

    trend ="stable"

    if len(older_moods) > 0:
        recent_avg = float(sum(recent_moods)) / len(recent_moods)
        older_avg = float(sum(older_moods)) / len (older_moods)

        if recent_avg > older_avg + 1:
            trend = "improving"
        elif recent_avg < older_avg - 1:
            trend = "declining"

    # 3. Filter: Get text from "Bad Days" (Mood <= 4)
    bad_entries_text = [e.content.lower() for e in entries if int(e.mood) <= 4]

    # 4. Check for specific keywords
    detected_triggers = []
    all_bad_text = " ".join(bad_entries_text)  

    if 'work' in all_bad_text or 'job' in all_bad_text or 'boss' in all_bad_text:
        detected_triggers.append("work stress")

    if 'sleep' in all_bad_text or 'tired' in all_bad_text or 'insomnia' in all_bad_text:
        detected_triggers.append("sleep quality")
    
    if 'lonely' in all_bad_text or 'alone' in all_bad_text:
        detected_triggers.append("social connection")
    # 5. Construct the Advice String
    advice = ""

    # PART A: The Opening
    if avg_mood >= 7:
        advice += "You've had a solid week! "
    elif avg_mood >= 4:
        advice += "Its been a bit of a mixed week. "
    else:
        advice += "You've had a tough run lately. Be gentle with yourself. "

    # PART B: The Trend
    if trend == "improving":
        advice += "Good news: Your mood is trending upward. "
    elif trend == "declining":
        advice += "I've notice your mood slipping recently." 

    # PART C: Specific Triggers
    if detected_triggers:
        triggers_str = ", ".join(detected_triggers)
        advice += f"I noticed recurring themes of {triggers_str} in your low-mood entries. "
        
        if "sleep quality" in detected_triggers:
            advice += "Try turning off screens 30 mins before bed. "
        if "work stress" in detected_triggers:
            advice += "Remember to take 5-minute micro-breaks. "
        
    # Final Return
    return {"advice": advice}
                       
# Delete Entry Route

@app.delete("/api/entries/{entry_id}")
async def delete_entry(entry_id: int, db: Session = Depends(get_db)):
    # 1. Find the entry by ID
    # We query for the entry where models.Entry.id matches the number we sent
    db_entry = db.query(models.Entry).filter(models.Entry.id == entry_id).first()

    # 2. Safety Check: Does it exist .
    if db_entry is None:
        # If not found, return a 404 error
        return {"error": "Entry not found"}
    
    # 3. Delete it
    db.delete(db_entry) # Stage the delete
    db.commit() # Save the change permanently

    return {"message": "Entry deleted succesfully"}

# Update Entry Route

@app.put("/api/entries/{entry_id}")
async def update_entry(entry_id: int, entry: JournalEntryUpdate, db: Session = Depends(get_db)):
    # 1. Find the entry
    db_entry = db.query(models.Entry).filter(models.Entry.id == entry_id).first()

    # 2. Check if it exists
    if db_entry is None:
        raise HTTPException(status_code=404, detail="Entry not found")

    # 3. Reject empty update payload
    if entry.content is None and entry.mood is None:
        raise HTTPException(status_code=400, detail="No fields provided for update")

    # 4. Update the fields that were sent by the client
    if entry.content is not None:
        db_entry.content = entry.content
        analysis = TextBlob(entry.content)
        db_entry.sentiment = analysis.sentiment.polarity

    if entry.mood is not None:
        db_entry.mood = entry.mood

    # 5. Save changes
    db.commit()
    db.refresh(db_entry)

    return {"message": "Updated successfully", "sentiment": db_entry.sentiment}
